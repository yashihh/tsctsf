/*
 * Ntsctsf_TimeSynchronization Service API
 *
 * TSCTSF Time Synchronization Service.   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * API version: 1.0.2
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package producer

import (
	"fmt"
	"math"
	"net/http"
	"strconv"

	"bitbucket.org/free5gc-team/openapi/models"
	"bitbucket.org/free5gc-team/util/httpwrapper"
	tsctsf_context "github.com/yashihh/tsctsf/internal/context"
	"github.com/yashihh/tsctsf/internal/logger"
	"github.com/yashihh/tsctsf/pkg/factory"
)

func HandleTimeSynchronizationExposureSubscriptions(request *httpwrapper.Request) *httpwrapper.Response {
	// step 1: log
	logger.TimeSyncSubLog.Infof("Handle Time Synchronization Exposure Subscriptions")
	// step 2: retrieve request
	timeSyncExpoSubscData := request.Body.(models.TimeSyncExposureSubsc)
	// step 3: handle the message
	url, problemDetails := TimeSyncExpoSubscPostProcedure(timeSyncExpoSubscData)

	// step 4: process the return value from step 3
	if problemDetails != nil {
		// status code is based on SPEC, and option headers
		// TODO: Based on TS 29.565 6.1.3.2.3.1, add location header
		return httpwrapper.NewResponse(int(problemDetails.Status), nil, problemDetails)
	}
	header := http.Header{
		"Location": {url},
	}
	return httpwrapper.NewResponse(http.StatusCreated, header, timeSyncExpoSubscData)

}

func TimeSyncExpoSubscPostProcedure(new_subsc models.TimeSyncExposureSubsc) (string, *models.ProblemDetails) {
	// store the appSession ID with DNN/S-NSSAI
	var subscription factory.Subscription
	var problemDetails *models.ProblemDetails
	// create a new subscription
	subscID, err := getUnusedSubscriptionID()
	if err != nil {
		logger.TimeSyncSubLog.Warnf(err.Error())

		*problemDetails = models.ProblemDetails{
			Title:  "Unsupported request resources",
			Status: http.StatusNotFound,
			Detail: err.Error(),
		}
		return "", problemDetails
	}

	// assign a subscription correlation ID
	subscription.SubscriptionId = subscID
	subscription.SubscriptionData = new(models.TimeSyncExposureSubsc)
	*subscription.SubscriptionData = new_subsc

	factory.TsctsfConfig.Subscriptions = append(factory.TsctsfConfig.Subscriptions, subscription)
	// TODO : select an expiry time that is equal to or less than the expiry time potentially received in the request;
	// if !subscription.SubscriptionData.Expiry.IsZero() {
	// 	response.Expiry = new(time.Time)
	// 	*response.Expiry = *subscription.SubscriptionData.Expiry
	// }

	tsctsf_self := tsctsf_context.GetSelf()
	dnnSnssai := new_subsc.Dnn + string(new_subsc.Snssai.Sst) + new_subsc.Snssai.Sd
	appSessID, exist := tsctsf_self.AppSessionIdPool.Load(dnnSnssai)
	if !exist {
		logger.TimeSyncSubLog.Errorln("No session found for the given DNN and S-NSSAI.")
		problemDetails := &models.ProblemDetails{
			Status: http.StatusNotFound,
			Cause:  "CONTEXT_NOT_FOUND",
		}
		return "", problemDetails
	}
	ID, exist := tsctsf_self.SubscripSession[appSessID.(string)]
	if exist {
		logger.TimeSyncSubLog.Errorln("AF-session has already subscribed with ID :", ID)

	} else {
		tsctsf_self.SubscripSession[appSessID.(string)] = subscID
		logger.TimeSyncSubLog.Infof("New Subscription ID : [%s]", subscID)
		resourceUri := fmt.Sprintf("ntsctsf-time-sync/v1/subscriptions/%s", subscID)
		return resourceUri, nil
	}
	return "", nil
}

func getUnusedSubscriptionID() (string, error) {
	var idx uint32 = 1
	factory.TsctsfConfig.RLock()
	defer factory.TsctsfConfig.RUnlock()
	for _, subscription := range factory.TsctsfConfig.Subscriptions {
		tempID, err := strconv.Atoi(subscription.SubscriptionId)
		if err != nil {
			return "", err
		}
		if uint32(tempID) == idx {
			if idx == math.MaxUint32 {
				return "", fmt.Errorf("No available subscription ID")
			}
			idx = idx + 1
		} else {
			break
		}
	}
	return strconv.Itoa(int(idx)), nil
}

func HandleDeleteIndividualTimeSynchronizationExposureSubscription(subscriptionID string) *httpwrapper.Response {
	logger.TimeSyncSubLog.Infoln("Handle Delete Individual Time Synchronization Exposure Subscription Request")

	tsctsf_self := tsctsf_context.GetSelf()
	var appSessionID string
	found := false

	for key, value := range tsctsf_self.SubscripSession {
		if value == subscriptionID {
			appSessionID = key
			found = true
			break
		}
	}

	if found {
		delete(tsctsf_self.SubscripSession, appSessionID)

		for i, subscription := range factory.TsctsfConfig.Subscriptions {
			if subscription.SubscriptionId == subscriptionID {
				factory.TsctsfConfig.Subscriptions = append(factory.TsctsfConfig.Subscriptions[:i],
					factory.TsctsfConfig.Subscriptions[i+1:]...)
			}
		}
		logger.TimeSyncSubLog.Infoln("Delete Individual Time Synchronization Exposure Subscription Sucessfully.")
	} else {
		logger.TimeSyncSubLog.Warnf("No Subscription[%s] with Appsession[%s]", subscriptionID, appSessionID)
		problemDetails := &models.ProblemDetails{
			Status: http.StatusNotFound,
			Cause:  "CONTEXT_NOT_FOUND",
		}
		return httpwrapper.NewResponse(int(problemDetails.Status), nil, problemDetails)
	}
	return httpwrapper.NewResponse(http.StatusNoContent, nil, nil)
}

func HandleGetIndividualTimeSynchronizationExposureSubscription(subscriptionID string) *httpwrapper.Response {
	logger.TimeSyncSubLog.Infoln("Handle Get Individual Time Synchronization Exposure Subscription Request")

	for _, subscription := range factory.TsctsfConfig.Subscriptions {
		if subscription.SubscriptionId == subscriptionID {
			logger.TimeSyncSubLog.Debugf("SubscriptionData: %+v", subscription.SubscriptionData)

			return httpwrapper.NewResponse(http.StatusOK, nil, subscription.SubscriptionData)
		}
	}
	logger.TimeSyncSubLog.Warnf("No Subscription ID[%s]", subscriptionID)
	problemDetails := &models.ProblemDetails{
		Status: http.StatusNotFound,
		Cause:  "CONTEXT_NOT_FOUND",
	}
	return httpwrapper.NewResponse(int(problemDetails.Status), nil, problemDetails)

}

func HandleReplaceIndividualTimeSynchronizationExposureSubscription(request *httpwrapper.Request) *httpwrapper.Response {
	logger.TimeSyncSubLog.Infoln("Handle Replace Individual Time Synchronization Exposure Subscription Request")
	timeSyncExpoSubscData := request.Body.(models.TimeSyncExposureSubsc)

	subscriptionID := request.Params["subscriptionId"]

	updatedSubscriptionData, problemDetails := TimeSyncExpoSubscModifyProcedure(timeSyncExpoSubscData, subscriptionID)
	if problemDetails != nil {
		return httpwrapper.NewResponse(int(problemDetails.Status), nil, problemDetails)
	} else {
		return httpwrapper.NewResponse(http.StatusOK, nil, updatedSubscriptionData)
	}
}

func TimeSyncExpoSubscModifyProcedure(timeSyncExpoSubscData models.TimeSyncExposureSubsc, subscriptionID string) (*models.TimeSyncExposureSubsc, *models.ProblemDetails) {
	for i, currentSubscription := range factory.TsctsfConfig.Subscriptions {
		if currentSubscription.SubscriptionId == subscriptionID {
			factory.TsctsfConfig.Subscriptions[i].SubscriptionData = &timeSyncExpoSubscData
			return currentSubscription.SubscriptionData, nil
		}
	}
	logger.TimeSyncSubLog.Warnf("Update Subscription data of Subscription ID[%s] fail.", subscriptionID)

	problemDetails := &models.ProblemDetails{
		Status: http.StatusNotFound,
		Cause:  "CONTEXT_NOT_FOUND",
	}

	return nil, problemDetails
}
